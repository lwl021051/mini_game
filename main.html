<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixel RPG Game</title>
    <style>
        canvas {
            background: #222;
            display: block;
            margin: auto;
            image-rendering: pixelated;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-size: 24px;
            display: none;
        }

        button {
            font-size: 18px;
            padding: 10px 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="gameOverScreen">
    <div>Game Over</div>
    <button onclick="restartGame()">Restart</button>
</div>
<!-- æ‰‹æ©ŸæŽ§åˆ¶æŒ‰éˆ• -->
<!-- æŽ§åˆ¶å€ -->
<div style="position: fixed; bottom: 20px; left: 20px;">
    <div style="display: flex; flex-direction: column; align-items: center;">
        <button onmousedown="pressMobileKey('w')" onmouseup="releaseMobileKey('w')" ontouchstart="pressMobileKey('w')"
                ontouchend="releaseMobileKey('w')">â–²
        </button>
        <div>
            <button onmousedown="pressMobileKey('a')" onmouseup="releaseMobileKey('a')"
                    ontouchstart="pressMobileKey('a')" ontouchend="releaseMobileKey('a')">â—€
            </button>
            <button onmousedown="pressMobileKey('s')" onmouseup="releaseMobileKey('s')"
                    ontouchstart="pressMobileKey('s')" ontouchend="releaseMobileKey('s')">â–¼
            </button>
            <button onmousedown="pressMobileKey('d')" onmouseup="releaseMobileKey('d')"
                    ontouchstart="pressMobileKey('d')" ontouchend="releaseMobileKey('d')">â–¶
            </button>
        </div>
    </div>
</div>
<div style="position: fixed; bottom: 20px; right: 20px;">
    <button
            onmousedown="pressMobileKey('k')"
            onmouseup="releaseMobileKey('k')"
            ontouchstart="pressMobileKey('k')"
            ontouchend="releaseMobileKey('k')"
            style="font-size: 20px;">ðŸ”¥ Attack
    </button>
</div>


<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TILE_SIZE = 32;
    const MAP_WIDTH = 1920;
    const MAP_HEIGHT = 1920;
    const VIEW_WIDTH = canvas.width;
    const VIEW_HEIGHT = canvas.height;

    const chickenWalk = new Image();
    chickenWalk.src = 'chicken_walk.png';

    const npcImage = new Image();
    npcImage.src = 'npc_image.png';

    const SPRITE_FRAME_WIDTH = 32;
    const SPRITE_FRAME_HEIGHT = 32;
    const FRAMES_PER_DIRECTION = 4;

    function createNPC() {
        return {
            x: Math.random() * MAP_WIDTH,
            y: Math.random() * MAP_HEIGHT,
            frame: 0,
            frameTick: 0,
            direction: 'down',
            health: 1
        };
    }

    let player = {
        x: 400,
        y: 400,
        width: 32,
        height: 32,
        isAttacking: false,
        speed: 2,
        direction: 'down',
        frame: 0,
        frameTick: 0,
        health: 3
    };

    const sandSpeed = 4;
    const fireCooldown = 200;
    let lastFireTime = 0;
    const sands = [];

    let npcs = [];
    let npcBaseSpeed = 0.5;
    let npcSpeed = npcBaseSpeed;

    let killCount = 0;
    let startTime = Date.now();

    const keys = {};
    window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        if (e.key.toLowerCase() === 'k') {
            const now = Date.now();
            if (now - lastFireTime > fireCooldown) {
                lastFireTime = now;
                let dx = 0, dy = 0;
                if (player.direction === 'up') dy = -1;
                if (player.direction === 'down') dy = 1;
                if (player.direction === 'left') dx = -1;
                if (player.direction === 'right') dx = 1;

                sands.push({
                    x: player.x + player.width / 2 - 4,
                    y: player.y + player.height / 2 - 4,
                    dx, dy,
                    distance: 0,
                    explosion: false,
                    explosionTick: 0
                });
            }
            player.isAttacking = true;
            setTimeout(() => player.isAttacking = false, 200);
        }
    });

    window.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
    });

    const directions = {
        down: 2,
        left: 1,
        up: 0,
        right: 3
    };

    function pressMobileKey(key) {
        keys[key] = true;

        if (key === 'k') {
            // ç«‹å³æ”»æ“Šï¼Œä½†ä¸æœƒè‡ªå‹•é‡‹æ”¾ key
            const now = Date.now();
            if (now - lastFireTime > fireCooldown) {
                lastFireTime = now;
                let dx = 0, dy = 0;
                if (player.direction === 'up') dy = -1;
                if (player.direction === 'down') dy = 1;
                if (player.direction === 'left') dx = -1;
                if (player.direction === 'right') dx = 1;

                sands.push({
                    x: player.x + player.width / 2 - 4,
                    y: player.y + player.height / 2 - 4,
                    dx, dy,
                    distance: 0,
                    explosion: false,
                    explosionTick: 0
                });
            }
            player.isAttacking = true;
        }
    }

    function releaseMobileKey(key) {
        keys[key] = false;
        if (key === 'k') {
            player.isAttacking = false;
        }
    }

    function update() {
        if (player.health <= 0) {
            showGameOver();
            return;
        }

        let moved = false;
        if (keys['w']) {
            player.y -= player.speed;
            player.direction = 'up';
            moved = true;
        }
        if (keys['s']) {
            player.y += player.speed;
            player.direction = 'down';
            moved = true;
        }
        if (keys['a']) {
            player.x -= player.speed;
            player.direction = 'left';
            moved = true;
        }
        if (keys['d']) {
            player.x += player.speed;
            player.direction = 'right';
            moved = true;
        }

        if (moved) {
            player.frameTick++;
            if (player.frameTick % 10 === 0) player.frame = (player.frame + 1) % FRAMES_PER_DIRECTION;
        } else {
            player.frame = 0;
        }

        player.x = Math.max(0, Math.min(MAP_WIDTH - TILE_SIZE, player.x));
        player.y = Math.max(0, Math.min(MAP_HEIGHT - TILE_SIZE, player.y));

        sands.forEach((sand, i) => {
            if (!sand.explosion) {
                sand.x += sand.dx * sandSpeed;
                sand.y += sand.dy * sandSpeed;
                sand.distance += sandSpeed;

                for (let j = 0; j < npcs.length; j++) {
                    const npc = npcs[j];
                    if (Math.abs(sand.x - npc.x) < TILE_SIZE && Math.abs(sand.y - npc.y) < TILE_SIZE) {
                        npcs.splice(j, 1);
                        sand.explosion = true;
                        sand.explosionTick = 10;
                        killCount++;
                        npcs.push(createNPC());
                        break;
                    }
                }

                if (sand.distance > TILE_SIZE * 10) {
                    sands.splice(i, 1);
                }
            } else {
                sand.explosionTick--;
                if (sand.explosionTick <= 0) sands.splice(i, 1);
            }
        });

        npcs.forEach((npc, i) => {
            let dx = player.x - npc.x;
            let dy = player.y - npc.y;
            let direction = '';

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) {
                    npc.x += npcSpeed;
                    direction = 'right';
                } else {
                    npc.x -= npcSpeed;
                    direction = 'left';
                }
            } else {
                if (dy > 0) {
                    npc.y += npcSpeed;
                    direction = 'down';
                } else {
                    npc.y -= npcSpeed;
                    direction = 'up';
                }
            }

            npc.direction = direction;

            npc.frameTick++;
            if (npc.frameTick % 10 === 0) {
                npc.frame = (npc.frame + 1) % FRAMES_PER_DIRECTION;
            }

            if (Math.abs(npc.x - player.x) < TILE_SIZE && Math.abs(npc.y - player.y) < TILE_SIZE) {
                player.health -= 1;
                npcs.splice(i, 1);
                npcs.push(createNPC());
            }
        });
    }

    function draw() {
        const camX = Math.max(0, Math.min(player.x - VIEW_WIDTH / 2, MAP_WIDTH - VIEW_WIDTH));
        const camY = Math.max(0, Math.min(player.y - VIEW_HEIGHT / 2, MAP_HEIGHT - VIEW_HEIGHT));

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < MAP_HEIGHT / TILE_SIZE; y++) {
            for (let x = 0; x < MAP_WIDTH / TILE_SIZE; x++) {
                ctx.fillStyle = (x + y) % 2 === 0 ? '#2e2e2e' : '#393939';
                ctx.fillRect(x * TILE_SIZE - camX, y * TILE_SIZE - camY, TILE_SIZE, TILE_SIZE);
            }
        }

        const frameX = player.frame * SPRITE_FRAME_WIDTH;
        const frameY = directions[player.direction] * SPRITE_FRAME_HEIGHT;

        ctx.drawImage(
            chickenWalk,
            frameX, frameY, SPRITE_FRAME_WIDTH, SPRITE_FRAME_HEIGHT,
            player.x - camX, player.y - camY, player.width, player.height
        );

        sands.forEach(sand => {
            if (!sand.explosion) {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(sand.x - camX, sand.y - camY, 8, 8);
            } else {
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.arc(sand.x - camX + 4, sand.y - camY + 4, 12, 0, 2 * Math.PI);
                ctx.fill();
            }
        });

        npcs.forEach(npc => {
            const frameX = npc.frame * SPRITE_FRAME_WIDTH;
            const frameY = directions[npc.direction] * SPRITE_FRAME_HEIGHT;

            ctx.drawImage(
                npcImage,
                frameX, frameY, SPRITE_FRAME_WIDTH, SPRITE_FRAME_HEIGHT,
                npc.x - camX, npc.y - camY, TILE_SIZE, TILE_SIZE
            );

            ctx.fillStyle = 'blue';
            ctx.fillRect(npc.x - camX, npc.y - camY - 10, TILE_SIZE, 5);
            ctx.fillStyle = 'green';
            ctx.fillRect(npc.x - camX, npc.y - camY - 10, TILE_SIZE, 5);
        });

        ctx.fillStyle = 'red';
        ctx.fillRect(player.x - camX, player.y - camY - 10, 30, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(player.x - camX, player.y - camY - 10, player.health * 10, 5);

        ctx.fillStyle = 'white';
        ctx.font = '16px sans-serif';
        ctx.fillText('Kills: ' + killCount, 10, 20);
    }

    function showGameOver() {
        document.getElementById('gameOverScreen').style.display = 'block';
    }

    function restartGame() {
        document.getElementById('gameOverScreen').style.display = 'none';
        player = {
            x: 400,
            y: 400,
            width: 32,
            height: 32,
            isAttacking: false,
            speed: 2,
            direction: 'down',
            frame: 0,
            frameTick: 0,
            health: 3
        };
        sands.length = 0;
        npcs = [];
        npcSpeed = npcBaseSpeed;
        killCount = 0;
        startTime = Date.now();

        for (let i = 0; i < 20; i++) {
            npcs.push(createNPC());
        }
        gameLoop();
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    for (let i = 0; i < 20; i++) {
        npcs.push(createNPC());
    }

    gameLoop();
</script>
</body>
</html>
