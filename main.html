<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Pixel RPG Game</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            display: block;
            background: #111;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TILE_SIZE = 32;
    const MAP_WIDTH = 1920;
    const MAP_HEIGHT = 1920;
    const SPRITE_FRAME_WIDTH = 32;
    const SPRITE_FRAME_HEIGHT = 32;
    const FRAMES_PER_DIRECTION = 4;
    const sandSpeed = 4;
    const fireCooldown = 200;

    const chickenWalk = new Image();
    chickenWalk.src = 'chicken_walk.png';

    const npcImage = new Image();
    npcImage.src = 'npc_image.png';

    let VIEW_WIDTH = window.innerWidth;
    let VIEW_HEIGHT = window.innerHeight;

    canvas.width = VIEW_WIDTH;
    canvas.height = VIEW_HEIGHT;

    const joystick = {
        baseX: 0,
        baseY: 0,
        radius: 50,
        knobX: 0,
        knobY: 0,
        active: false,
        touchId: null,
    };

    const buttons = {
        attack: { x: canvas.width - 80, y: canvas.height - 80, w: 60, h: 60, key: 'k' },
        restart: { x: canvas.width / 2 - 60, y: canvas.height / 2 - 30, w: 120, h: 60, key: null }
    };

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        VIEW_WIDTH = canvas.width;
        VIEW_HEIGHT = canvas.height;

        joystick.baseX = canvas.width * 0.15;
        joystick.baseY = canvas.height * 0.85;
        joystick.knobX = joystick.baseX;
        joystick.knobY = joystick.baseY;

        const btnSize = Math.min(canvas.width, canvas.height) / 8;
        buttons.attack = { x: canvas.width - btnSize * 2, y: canvas.height - btnSize * 2, w: btnSize, h: btnSize, key: 'k' };
        buttons.restart = { x: canvas.width / 2 - btnSize, y: canvas.height / 2 - btnSize / 2, w: btnSize * 2, h: btnSize, key: null };
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const directions = { down: 2, left: 1, up: 0, right: 3 };
    const keys = {};
    const sands = [];
    const npcs = [];
    let player = {};
    let killCount = 0;
    let gameOver = false;
    let lastFireTime = 0;
    let npcBaseSpeed = 0.5;
    let npcSpeed = npcBaseSpeed;

    function createNPC() {
        return {
            x: Math.random() * MAP_WIDTH,
            y: Math.random() * MAP_HEIGHT,
            frame: 0,
            frameTick: 0,
            direction: 'down',
            health: 1
        };
    }

    function restartGame() {
        player = {
            x: 400,
            y: 400,
            width: 32,
            height: 32,
            isAttacking: false,
            speed: 2,
            direction: 'down',
            frame: 0,
            frameTick: 0,
            health: 3
        };
        sands.length = 0;
        npcs.length = 0;
        for (let i = 0; i < 20; i++) npcs.push(createNPC());
        killCount = 0;
        gameOver = false;
    }

    function fireSand() {
        if (gameOver) return;
        const now = Date.now();
        if (now - lastFireTime > fireCooldown) {
            lastFireTime = now;
            let dx = 0, dy = 0;
            if (player.direction === 'up') dy = -1;
            if (player.direction === 'down') dy = 1;
            if (player.direction === 'left') dx = -1;
            if (player.direction === 'right') dx = 1;

            sands.push({
                x: player.x + player.width / 2 - 4,
                y: player.y + player.height / 2 - 4,
                dx, dy,
                distance: 0,
                explosion: false,
                explosionTick: 0
            });

            player.isAttacking = true;
            setTimeout(() => player.isAttacking = false, 200);
        }
    }

    function update() {
        if (player.health <= 0) {
            gameOver = true;
            return;
        }

        let moved = false;
        if (keys['w']) { player.y -= player.speed; player.direction = 'up'; moved = true; }
        if (keys['s']) { player.y += player.speed; player.direction = 'down'; moved = true; }
        if (keys['a']) { player.x -= player.speed; player.direction = 'left'; moved = true; }
        if (keys['d']) { player.x += player.speed; player.direction = 'right'; moved = true; }

        if (moved) {
            player.frameTick++;
            if (player.frameTick % 10 === 0) player.frame = (player.frame + 1) % FRAMES_PER_DIRECTION;
        } else player.frame = 0;

        player.x = Math.max(0, Math.min(MAP_WIDTH - TILE_SIZE, player.x));
        player.y = Math.max(0, Math.min(MAP_HEIGHT - TILE_SIZE, player.y));

        sands.forEach((sand, i) => {
            if (!sand.explosion) {
                sand.x += sand.dx * sandSpeed;
                sand.y += sand.dy * sandSpeed;
                sand.distance += sandSpeed;

                for (let j = 0; j < npcs.length; j++) {
                    const npc = npcs[j];
                    if (Math.abs(sand.x - npc.x) < TILE_SIZE && Math.abs(sand.y - npc.y) < TILE_SIZE) {
                        npcs.splice(j, 1);
                        sand.explosion = true;
                        sand.explosionTick = 10;
                        killCount++;
                        npcs.push(createNPC());
                        break;
                    }
                }

                if (sand.distance > TILE_SIZE * 10) sands.splice(i, 1);
            } else {
                sand.explosionTick--;
                if (sand.explosionTick <= 0) sands.splice(i, 1);
            }
        });

        npcs.forEach((npc, i) => {
            let dx = player.x - npc.x;
            let dy = player.y - npc.y;
            let direction = '';

            if (Math.abs(dx) > Math.abs(dy)) {
                npc.x += dx > 0 ? npcSpeed : -npcSpeed;
                direction = dx > 0 ? 'right' : 'left';
            } else {
                npc.y += dy > 0 ? npcSpeed : -npcSpeed;
                direction = dy > 0 ? 'down' : 'up';
            }

            npc.direction = direction;
            npc.frameTick++;
            if (npc.frameTick % 10 === 0) npc.frame = (npc.frame + 1) % FRAMES_PER_DIRECTION;

            if (Math.abs(npc.x - player.x) < TILE_SIZE && Math.abs(npc.y - player.y) < TILE_SIZE) {
                player.health--;
                npcs.splice(i, 1);
                npcs.push(createNPC());
            }
        });
    }

    function drawJoystick() {
        if (!joystick.active) return;
        ctx.beginPath();
        ctx.arc(joystick.baseX, joystick.baseY, joystick.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.fill();
        ctx.beginPath();
        ctx.arc(joystick.knobX, joystick.knobY, 20, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255,255,255,0.6)";
        ctx.fill();
    }

    function drawControls() {
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#888';

        for (let name in buttons) {
            const b = buttons[name];
            if (name === 'restart' && !gameOver) continue;
            ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.fillStyle = '#fff';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(name === 'restart' ? 'Restart' : name, b.x + b.w / 2, b.y + b.h / 2);
            ctx.fillStyle = '#888';
        }

        ctx.globalAlpha = 1;
    }

    function draw() {
        const camX = Math.max(0, Math.min(player.x - VIEW_WIDTH / 2, MAP_WIDTH - VIEW_WIDTH));
        const camY = Math.max(0, Math.min(player.y - VIEW_HEIGHT / 2, MAP_HEIGHT - VIEW_HEIGHT));

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let y = 0; y < MAP_HEIGHT / TILE_SIZE; y++) {
            for (let x = 0; x < MAP_WIDTH / TILE_SIZE; x++) {
                ctx.fillStyle = (x + y) % 2 === 0 ? '#2e2e2e' : '#393939';
                ctx.fillRect(x * TILE_SIZE - camX, y * TILE_SIZE - camY, TILE_SIZE, TILE_SIZE);
            }
        }

        const frameX = player.frame * SPRITE_FRAME_WIDTH;
        const frameY = directions[player.direction] * SPRITE_FRAME_HEIGHT;
        ctx.drawImage(chickenWalk, frameX, frameY, SPRITE_FRAME_WIDTH, SPRITE_FRAME_HEIGHT,
            player.x - camX, player.y - camY, player.width, player.height);

        sands.forEach(sand => {
            if (!sand.explosion) {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(sand.x - camX, sand.y - camY, 8, 8);
            } else {
                ctx.fillStyle = 'orange';
                ctx.beginPath();
                ctx.arc(sand.x - camX + 4, sand.y - camY + 4, 12, 0, 2 * Math.PI);
                ctx.fill();
            }
        });

        npcs.forEach(npc => {
            const frameX = npc.frame * SPRITE_FRAME_WIDTH;
            const frameY = directions[npc.direction] * SPRITE_FRAME_HEIGHT;
            ctx.drawImage(npcImage, frameX, frameY, SPRITE_FRAME_WIDTH, SPRITE_FRAME_HEIGHT,
                npc.x - camX, npc.y - camY, TILE_SIZE, TILE_SIZE);
        });

        ctx.fillStyle = 'red';
        ctx.fillRect(player.x - camX, player.y - camY - 10, 30, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(player.x - camX, player.y - camY - 10, player.health * 10, 5);

        ctx.fillStyle = 'white';
        ctx.font = '16px sans-serif';
        ctx.fillText('Kills: ' + killCount, 30, 20);

        drawControls();
        drawJoystick();
    }

    canvas.addEventListener('mousedown', e => handleClick(e, true));
    canvas.addEventListener('mouseup', () => { for (let key in keys) keys[key] = false; });
    canvas.addEventListener('touchstart', e => {
        for (const touch of e.touches) {
            const dx = touch.clientX - joystick.baseX;
            const dy = touch.clientY - joystick.baseY;
            if (Math.sqrt(dx * dx + dy * dy) < joystick.radius * 2) {
                joystick.active = true;
                joystick.touchId = touch.identifier;
                joystick.knobX = touch.clientX;
                joystick.knobY = touch.clientY;
            }
        }
    });
    canvas.addEventListener('touchmove', e => {
        for (const touch of e.touches) {
            if (touch.identifier === joystick.touchId) {
                const dx = touch.clientX - joystick.baseX;
                const dy = touch.clientY - joystick.baseY;
                const dist = Math.min(Math.sqrt(dx * dx + dy * dy), joystick.radius);
                const angle = Math.atan2(dy, dx);
                joystick.knobX = joystick.baseX + Math.cos(angle) * dist;
                joystick.knobY = joystick.baseY + Math.sin(angle) * dist;
                player.x += Math.cos(angle) * player.speed;
                player.y += Math.sin(angle) * player.speed;
            }
        }
    });
    canvas.addEventListener('touchend', e => {
        for (const touch of e.changedTouches) {
            if (touch.identifier === joystick.touchId) {
                joystick.active = false;
                joystick.touchId = null;
                joystick.knobX = joystick.baseX;
                joystick.knobY = joystick.baseY;
            }
        }
    });

    function handleClick(e, isMouseDown = false) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        for (let name in buttons) {
            const btn = buttons[name];
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                if (name === 'restart') restartGame();
                else if (btn.key === 'k') fireSand();
                else if (btn.key) {
                    keys[btn.key] = true;
                    if (!isMouseDown) setTimeout(() => keys[btn.key] = false, 200);
                }
            }
        }
    }

    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    restartGame();
    gameLoop();
</script>
</body>
</html>
